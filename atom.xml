<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>jingxiao&#39;s space</title>
  
  
  <link href="https://jingxiao-yz.github.io/atom.xml" rel="self"/>
  
  <link href="https://jingxiao-yz.github.io/"/>
  <updated>2023-05-12T03:54:42.137Z</updated>
  <id>https://jingxiao-yz.github.io/</id>
  
  <author>
    <name>jingxiao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>从 FileInputStream.read()方法 到 Windows api ReadFile()</title>
    <link href="https://jingxiao-yz.github.io/2023/05/09/aboutstream/"/>
    <id>https://jingxiao-yz.github.io/2023/05/09/aboutstream/</id>
    <published>2023-05-09T12:09:14.000Z</published>
    <updated>2023-05-12T03:54:42.137Z</updated>
    
    <content type="html"><![CDATA[<p>Java 使用 IO 流进行文件的读写应该是非常基本的操作了，在之前的一个练习项目中，有个浏览器上传图片即时回显功能用到了这个步骤，即将上传到服务器的图片读出来写回到浏览器响应里，最终展示在浏览器页面上：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">...省略</span><br><span class="line">    <span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="keyword">new</span> <span class="title class_">File</span>(basePath + name));</span><br><span class="line">    <span class="type">ServletOutputStream</span> <span class="variable">outputStream</span> <span class="operator">=</span> response.getOutputStream();</span><br><span class="line">...省略</span><br><span class="line">    <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">byte</span>[] bytes = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">1024</span>];</span><br><span class="line">    <span class="keyword">while</span> ((len = fileInputStream.read(bytes)) != -<span class="number">1</span>) &#123;</span><br><span class="line">        outputStream.write(bytes, <span class="number">0</span>, len);</span><br><span class="line">        outputStream.flush();</span><br><span class="line">    &#125;</span><br><span class="line">...省略</span><br></pre></td></tr></table></figure><h2 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h2><p>一开始对 <code>while ((len = fileInputStream.read(bytes)) != -1)</code> 这行代码是有疑问的，按我的理解：</p><ul><li><code>read</code>方法可以不接收参数，返回输入流的下一个字节数据；</li><li>也可以接收一个<code>byte[] b</code>，数组<code>b</code>称之为缓冲区，将输入流的数据存到<code>b</code>中，同时返回读取的字节数量</li></ul><p>而我当时的疑问是：</p><ul><li>如果<code>read</code>方法不接受参数还好，当未读取任何字节时，返回<code>-1</code>，表示文件末尾，此时变量<code>len</code>被赋值<code>-1</code>，循环结束；</li><li>但是当传入<code>byte</code>数组时，<code>len</code>应该是读入的数据长度呀，就算读到末尾没数据了，长度也应该时<code>0</code>呀，长度怎么会是<code>-1</code>，那不就死循环了嘛，但是实际代码确实可以正常运行的。</li></ul><p>那么，这肯定要去看看<code>read(byte[] b)</code>是怎么实现计数的，定位到<code>FileInputStream.java</code>中的<code>read</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Reads up to &#123;<span class="doctag">@code</span> b.length&#125; bytes of data from this input</span></span><br><span class="line"><span class="comment"> * stream into an array of bytes. This method blocks until some input</span></span><br><span class="line"><span class="comment"> * is available.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>      b   &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span>     the total number of bytes read into the buffer, or</span></span><br><span class="line"><span class="comment"> *             &#123;<span class="doctag">@code</span> -1&#125; if there is no more data because the end of</span></span><br><span class="line"><span class="comment"> *             the file has been reached.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>     IOException  if an I/O error occurs.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="type">int</span> <span class="title function_">read</span><span class="params">(<span class="type">byte</span>[] b)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="type">long</span> <span class="variable">comp</span> <span class="operator">=</span> Blocker.begin();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> readBytes(b, <span class="number">0</span>, b.length);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Blocker.end(comp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好吧，在注释第<code>7</code>行写了，大意是 “返回读到<code>buffer</code>里字节的数量，如果到文件末尾没数据了，返回<code>-1</code>”，这么看，就是咱不熟悉这个方法的返回值呀。<br>为了求证这个事情，自己也简单测试了一下：<br>先准备一个文件<code>in.txt</code>，里面有<code>12</code>个字母数据<code>aaabbbcccddd</code>，每个字母占1个字节空间，同时设置一个大小为<code>10</code>的byte数组<code>b</code>来做缓冲，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        <span class="keyword">try</span> (<span class="type">FileInputStream</span> <span class="variable">fileInputStream</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileInputStream</span>(<span class="string">&quot;D:\\Desktop\\in1.txt&quot;</span>)) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="type">byte</span> b[] = <span class="keyword">new</span> <span class="title class_">byte</span>[<span class="number">10</span>];</span><br><span class="line">            <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> ((len = fileInputStream.read(b)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;第&quot;</span> + j + <span class="string">&quot;次读入数量len=&quot;</span> + len);</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">&quot;最后读入数量len=&quot;</span> + len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>来看看变量<code>len</code>的控制台输出：<br><img src="/2023/05/09/aboutstream/1.png" alt="1"><br>果然，在读取完文件数据后，<code>len</code>最后的值为<code>-1</code>，</p><p>由于<code>FileInputStream</code>继承自抽象类<code>InputStream</code>，所以<code>FileInputStream</code>里 重写了 <code>read()</code>，其实就是调用了另一个方法： <code>readBytes()</code>，又定位到这个方法，还是一个 <code>native</code> 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Reads a subarray as a sequence of bytes.</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>     b the data to be written</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>     off the start offset in the data</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span>     len the number of bytes that are written</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@throws</span>    IOException If an I/O error has occurred.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">native</span> <span class="type">int</span> <span class="title function_">readBytes</span><span class="params">(<span class="type">byte</span>[] b, <span class="type">int</span> off, <span class="type">int</span> len)</span> <span class="keyword">throws</span> IOException;</span><br></pre></td></tr></table></figure><p>其实看到前面注释里关于返回值的说明，关于<code>-1</code>疑问也算消除了，不过我比较关心的是：</p><h2 id="那这个native方法readBytes-到底是怎么计算所读字节的个数？"><a href="#那这个native方法readBytes-到底是怎么计算所读字节的个数？" class="headerlink" title="那这个native方法readBytes()到底是怎么计算所读字节的个数？"></a>那这个native方法readBytes()到底是怎么计算所读字节的个数？</h2><p>因为<code>native</code>方法是Java调用非Java代码的接口，使得Java虚拟机中的Java程序可以调用本地应用&#x2F;或库，在本地IDE里面无法定位到这个函数的声明或定义，它位于 <strong>openjdk</strong> 源码中。<br>在 <strong>GitHub</strong> 上找到 <strong>openjdk</strong> 项目的代码，我在目录：<code>jdk/src/java.base/share/native/libjava/</code> 下找到了 <strong>FileInputStream.c</strong> 源文件（可能因后期项目更新而路径变化），里面有 <code>readBytes()</code> 的具体实现：<code>Java_java_io_FileInputStream_readBytes()</code>，关于这个名字的样子说下，它遵守 <strong>JNI</strong>（Java native interface）方法命名规则：</p><ul><li>Java_前缀</li><li>全限定的类名</li><li>下划线（_）分隔符</li><li>增加第一参数JNIEnv* env</li><li>增加第二个参数jobject</li><li>其他参数按类型映射</li><li>返回值按类型映射</li></ul><p>就是说：<code>readBytes()</code>在<code>java.io.FileInputStream</code>这个类里面，类名加上前缀，点号换成下划线，最后加上Java中 方法自己的名字。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">JNIEXPORT jint JNICALL</span><br><span class="line"><span class="title function_">Java_java_io_FileInputStream_readBytes</span><span class="params">(JNIEnv *env, jobject this,</span></span><br><span class="line"><span class="params">        jbyteArray bytes, jint off, jint len)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> readBytes(env, this, bytes, off, len, fis_fd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于这个<code>native</code>方法的几个参数类型，搜索了一下</p><ul><li><p><code>JNIEnv</code>，全称是<code>Java native interface environment</code>（Java本地接口环境），所有的本地方法的第一个参数都是指向JNIEnv结构的，即这个方法接收的指针 <code>env</code> 指向了本地方法的一个函数表，该函数表中的每一个成员指向了一个JNI函数，本地方法通过JNI函数来访问JVM中的数据结构，具体如图（侵删）：<img src="/2023/05/09/aboutstream/jni.png" alt="jni"></p></li><li><p><code>jobject</code> 第二个参数通常是<code>jobject</code>或<code>jclass</code>，对应Java中的<code>Object</code>和<code>Class</code>，当所声明的native方法是静态方法时，对应参数是jclass，因为静态方法不依赖对象实例，而依赖于类，所以传递一个jclass类型。相反，如果声明的native方法是非静态方法时，那么对应参数是jobject。具体到这里，这个native方法对应的是FileInputStream里面的read方法，它是非静态的，依赖我们实例化一个输入流对象，并调用read()才存在的。</p></li><li><p><code>jbyteArray</code> 和 <code>jint</code> 对应的就是Java里面的 <code>byteArray</code> 和 <code>int</code> 类型。除了第1、2个参数固定，后面的参数就是对应的Java方法的参数，我们在Java方法中传入了一个byte数组和两个int数字，所以后面还有这三个参数。</p></li></ul><p>但是这个函数的实现是调用的另一个 <code>C函数readBytes()</code>，（这里不得不说GitHub真好用！）选中<code>readBytes</code>这个函数名，Github会搜索项目所有文件中的相同字符，于是，我在目录：<code>jdk/src/java.base/share/native/libjava/</code>下的 <strong>io_util.c</strong> 文件中找到了这个函数的定义实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">jint <span class="comment">//返回值类型 jint对应int</span></span><br><span class="line">readBytes(JNIEnv *env, jobject this, jbyteArray bytes,</span><br><span class="line">          jint off, jint len, jfieldID fid)<span class="comment">//jfieldID 可用于获取类中变量的标识，然后通过此标识来读写变量</span></span><br><span class="line">&#123;</span><br><span class="line">    jint nread; <span class="comment">//最终的返回值</span></span><br><span class="line">    <span class="type">char</span> stackBuf[BUF_SIZE]; <span class="comment">//建一个char数组</span></span><br><span class="line">    <span class="type">char</span> *buf = <span class="literal">NULL</span>; <span class="comment">//char指针</span></span><br><span class="line">    FD fd;</span><br><span class="line">    <span class="comment">// FD 是File Descriptor，文件描述符。文件描述符是一个 非负整数，本质上是一个索引值。</span></span><br><span class="line">    <span class="comment">// 在src/java.base/unix/native/libjava/io_util_md.h中有定义# define FD jint，所以FD相当于是个int类型</span></span><br><span class="line">    <span class="comment">// 后续read/write 这个文件时，只需要用这个文件描述符来标识该文件，将其作为参数传入read/write</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (IS_NULL(bytes)) &#123;<span class="comment">//传入的byte数组为空，返回-1（也就是存不了呗）</span></span><br><span class="line">        JNU_ThrowNullPointerException(env, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (outOfBounds(env, off, len, bytes)) &#123; <span class="comment">//参数越界</span></span><br><span class="line">        JNU_ThrowByName(env, <span class="string">&quot;java/lang/IndexOutOfBoundsException&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len &gt; BUF_SIZE) &#123; <span class="comment">//len大于BUF_SIZE</span></span><br><span class="line">        buf = <span class="built_in">malloc</span>(len); <span class="comment">//重新分配一块len大小的内存空间，并把buf指向这块地</span></span><br><span class="line">        <span class="keyword">if</span> (buf == <span class="literal">NULL</span>) &#123; <span class="comment">//没分到，说明内存不够了</span></span><br><span class="line">            JNU_ThrowOutOfMemoryError(env, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//一切正常的话，buf指向stackBuf[]</span></span><br><span class="line">        buf = stackBuf;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    fd = getFD(env, this, fid); <span class="comment">//通过 this 和 fid 获取文件描述符fd</span></span><br><span class="line">    <span class="keyword">if</span> (fd == <span class="number">-1</span>) &#123;</span><br><span class="line">        JNU_ThrowIOException(env, <span class="string">&quot;Stream Closed&quot;</span>);</span><br><span class="line">        nread = <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//fd一半为非负整数</span></span><br><span class="line">        nread = IO_Read(fd, buf, len); <span class="comment">//  调用IO_Read(), 传入 fd 来操作文件，所读字节数赋给nread</span></span><br><span class="line">        <span class="keyword">if</span> (nread &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            (*env)-&gt;SetByteArrayRegion(env, bytes, off, nread, (jbyte *)buf); <span class="comment">//将本地的数组数据拷贝到了 Java 端的数组 bytes</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nread == <span class="number">-1</span>) &#123;</span><br><span class="line">            JNU_ThrowIOExceptionWithLastError(env, <span class="string">&quot;Read error&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">/* EOF */</span></span><br><span class="line">            nread = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (buf != stackBuf) &#123;</span><br><span class="line">        <span class="built_in">free</span>(buf); <span class="comment">//释放buf指向的空间</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nread; <span class="comment">//返回所读字节数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码我尽量注释了，涉及到 <strong>文件描述符</strong> 的部分我可能有理解错误，但影响不大。可以看见，在第<code>40</code>行，最关键的读文件步骤，是调用了 <code>IO_Read()</code> 函数，好吧，继续找，在头文件：<code>jdk/src/java.base/windows/native/libjava/</code><strong>io_util_md.h</strong> 中，有定义<code>#define IO_Read handleRead</code>，也就是说 <code>IO_Read</code> 就是 <code>handleRead</code>，那继续顺藤摸瓜找 <code>handleRead</code> 的定义实现，很明显应该在这个头文件对应的c代码文件里面，也就是 <code>jdk/src/java.base/windows/native/libjava/</code><strong>io_util_md.c</strong> 中，果然找到了它的实现，代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">JNIEXPORT</span><br><span class="line">jint</span><br><span class="line"><span class="title function_">handleRead</span><span class="params">(FD fd, <span class="type">void</span> *buf, jint len)</span> <span class="comment">//句柄读，句柄是Windows用来标识被应用程序所建立或使用的对象的唯一整数</span></span><br><span class="line">&#123;</span><br><span class="line">    DWORD read = <span class="number">0</span>; <span class="comment">// 所读字节数量，最终返回值，取地址传入ReadFile()中操作</span></span><br><span class="line">    BOOL result = <span class="number">0</span>;</span><br><span class="line">    HANDLE h = (HANDLE)fd; <span class="comment">//将 文件描述符 转为 句柄</span></span><br><span class="line">    <span class="keyword">if</span> (h == INVALID_HANDLE_VALUE) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    result = ReadFile(h,          <span class="comment">/* File handle to read */</span></span><br><span class="line">                      buf,        <span class="comment">/* address to put data */</span></span><br><span class="line">                      len,        <span class="comment">/* number of bytes to read */</span></span><br><span class="line">                      &amp;read,      <span class="comment">/* number of bytes read */</span></span><br><span class="line">                      <span class="literal">NULL</span>);      <span class="comment">/* no overlapped struct */</span></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="type">int</span> error = GetLastError();</span><br><span class="line">        <span class="keyword">if</span> (error == ERROR_BROKEN_PIPE) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">/* EOF */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (jint)read;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果发现，最终的读文件操作还是调的一个函数 <code>ReadFile()</code>，虽然有注释，即返回第 <strong>4</strong> 个参数指针指向的变量，但是这个函数在 <strong>openjdk</strong> 项目文件中是没有定义的，怎么办呢，尝试搜索了一下这个函数，居然是 <strong>Windows</strong> 应用开发的一个函数，贴个地址吧 <a href="https://learn.microsoft.com/zh-cn/windows/win32/api/fileapi/nf-fileapi-readfile">https://learn.microsoft.com/zh-cn/windows/win32/api/fileapi/nf-fileapi-readfile</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">ReadFile</span><span class="params">(</span></span><br><span class="line"><span class="params">  [in]                HANDLE       hFile,</span></span><br><span class="line"><span class="params">  [out]               LPVOID       lpBuffer,</span></span><br><span class="line"><span class="params">  [in]                DWORD        nNumberOfBytesToRead,</span></span><br><span class="line"><span class="params">  [out, optional]     LPDWORD      lpNumberOfBytesRead,</span></span><br><span class="line"><span class="params">  [in, out, optional] LPOVERLAPPED lpOverlapped</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure><p>关键看官方文档有关第<strong>4</strong>个参数的解释：<img src="/2023/05/09/aboutstream/readfileexplain.png" alt="213"><br>大意就是，这个位置的参数是个指针，指向 接收读取的字节数的变量xxx，<code>ReadFile()</code>会初始化这个xxx的值为 0。</p><p>回到<strong>openjdk</strong>里面的<code>handleRead()</code>，第4个位置传入的指针就是变量<code>read</code>的地址，经过调用<strong>Windows</strong>的<code>ReadFile()</code>一顿黑箱操作，就把将<code>read</code>的值变为了 读取的字节数量，最后将<code>read</code>返回给上一层。</p><p>我捋了下这个调用链：<br>fileInputstream.<strong>read</strong>(byte[] b) 【FileInputStream.java】—&gt; <strong>readBytes()</strong> 【FileInputStream.java，native】—JNI—&gt; <strong>Java_java_io_FileInputStream_readBytes()</strong> 【FileInputStream.c】—&gt; <strong>readBytes()</strong> 【io_util.c】—&gt; <strong>IO_Read()</strong> 【io_util_md.h】—&gt; <strong>handleRead()</strong> 【io_util_md.c】—&gt; <strong>ReadFile()</strong> 【fileapi.h，Windows】</p><p><strong>这里总算是到头了，毕竟Windows的代码不开源，绕一大圈结果还是不知道它怎么计算读取的字节数的</strong></p><p>不过回过头来看，JNI这个框架，它的目的就是<strong>使得Java虚拟机中的Java程序可以调用本地应用或库</strong>，在Openjdk项目代码里面查调用链的时候，发现有平行的windows、Linux、macosx等文件夹目录存在，里面都是相应平台上native方法的实现代码，究其原因就是有些程序可能会涉及到调用系统的api，所以分开来，大家各司其职。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Java 使用 IO 流进行文件的读写应该是非常基本的操作了，在之前的一个练习项目中，有个浏览器上传图片即时回显功能用到了这个步骤，即将上传到服务器的图片读出来写回到浏览器响应里，最终展示在浏览器页面上：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>LeetCode_Hot_100</title>
    <link href="https://jingxiao-yz.github.io/2023/05/04/LeetCode-Hot-100/"/>
    <id>https://jingxiao-yz.github.io/2023/05/04/LeetCode-Hot-100/</id>
    <published>2023-05-04T12:14:51.000Z</published>
    <updated>2023-05-19T16:25:50.327Z</updated>
    
    <content type="html"><![CDATA[<h1 id="LeetCode-热题-100"><a href="#LeetCode-热题-100" class="headerlink" title=" LeetCode 热题 100"></a><center> <a href="https://leetcode.cn/studyplan/top-100-liked/">LeetCode 热题 100</a></center></h1><h2 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a><center>哈希</center></h2><h3 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a><a href="https://leetcode.cn/problems/two-sum/?envType=study-plan-v2&id=top-100-liked">1. 两数之和</a></h3><p><strong>Map</strong> 把数组index作为value保存</p><h3 id="49-字母异位词分组"><a href="#49-字母异位词分组" class="headerlink" title="49. 字母异位词分组"></a><a href="https://leetcode.cn/problems/group-anagrams/?envType=study-plan-v2&id=top-100-liked">49. 字母异位词分组</a></h3><p><strong><code>hashmap.getOrDefault(Object key, V defaultValue)</code></strong> 获取指定 key 对应对 value，如果找不到 key ，则返回设置的默认值。把排序后相同str当作key</p><h2 id="128-最长连续序列"><a href="#128-最长连续序列" class="headerlink" title="128. 最长连续序列"></a><a href="https://leetcode.cn/problems/longest-consecutive-sequence/">128. 最长连续序列</a></h2><p><strong>Set</strong> 时间复杂度要求O(n)，那只有用空间来换时间，把数组转换到set里面来处理</p><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a><center>双指针</center></h2><h3 id="15-三数之和"><a href="#15-三数之和" class="headerlink" title="15. 三数之和"></a><a href="https://leetcode.cn/problems/3sum/?envType=study-plan-v2&id=top-100-liked">15. 三数之和</a></h3><ul><li><strong>先排序！先排序！先排序！</strong></li><li><strong><code>if(left &gt; 0 &amp;&amp; nums[left] == nums[left-1])</code></strong> 去重去重的前提是“当前数字，之前用过了，所以才跳过当前数字”；而不是因为 “后面有相同的当前数字，就不用当前数字”</li><li><strong><code>Arrays.asList(1，2，3)</code></strong> 把几个值转为一个list</li></ul><h3 id="283-移动零"><a href="#283-移动零" class="headerlink" title="283. 移动零"></a><a href="https://leetcode.cn/problems/move-zeroes/">283. 移动零</a></h3><p>快慢指针，快指针遍历时，若不为0，将当前值fast赋给slow，slow加1，由于fast在前面，直接覆盖就是，由于是以fast为遍历索引，结束时注意填充尾部的0</p><h3 id="11-盛最多水的容器"><a href="#11-盛最多水的容器" class="headerlink" title="11. 盛最多水的容器"></a><a href="https://leetcode.cn/problems/container-with-most-water/">11. 盛最多水的容器</a></h3><p>左右指针，向内靠拢，短边先动</p><h3 id="42-接雨水"><a href="#42-接雨水" class="headerlink" title="42. 接雨水"></a><a href="https://leetcode.cn/problems/trapping-rain-water/">42. 接雨水</a></h3><p>对于每一列，找其出左右两边的最高列，当前列 一定会淹没在 它左边最高列和右边最高列构成的 凹槽 里面，找出水面高度（即较小的边），累加当前列对应的水量高度即可</p><h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a><center>滑动窗口</center></h2><h3 id="3-无重复字符的最长子串"><a href="#3-无重复字符的最长子串" class="headerlink" title="3. 无重复字符的最长子串"></a><a href="https://leetcode.cn/problems/longest-substring-without-repeating-characters/">3. 无重复字符的最长子串</a></h3><p>用 <strong>Set</strong> 来保存不同的值，快慢指针遍历比较，遇到相同的把slow的先去除</p><h3 id="438-找到字符串中所有字母异位词"><a href="#438-找到字符串中所有字母异位词" class="headerlink" title="438. 找到字符串中所有字母异位词"></a><a href="https://leetcode.cn/problems/find-all-anagrams-in-a-string/">438. 找到字符串中所有字母异位词</a></h3><ul><li><strong>Arrays.equals(array1,array2)</strong> 判等</li><li>用字典保存字符串str所含字母信息：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] strdict = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">26</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; strlen; i++) strdict[str.charAt(i) - <span class="string">&#x27;a&#x27;</span>]++;</span><br></pre></td></tr></table></figure><p>维护一个相同长度的窗口字典，注意边界条件处理，移动窗口，左边的字母去掉，右边的字母加上，判断维护的两个字典数组是否相等</p><h2 id="字串"><a href="#字串" class="headerlink" title="字串"></a><center>字串</center></h2><h3 id="239-滑动窗口最大值"><a href="#239-滑动窗口最大值" class="headerlink" title="239. 滑动窗口最大值"></a><a href="https://leetcode.cn/problems/sliding-window-maximum/?envType=study-plan-v2&id=top-100-liked">239. 滑动窗口最大值</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 队列中保存下标，对应的数组数值从大到小排列，队首是窗口内最大值的下标</span></span><br><span class="line"><span class="keyword">while</span> (!zhan.isEmpty() &amp;&amp; nums[R] &gt;= nums[zhan.peekLast()])&#123;</span><br><span class="line">    zhan.removeLast();</span><br><span class="line">&#125;</span><br><span class="line">zhan.addLast(R);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用优先队列会超时，优先队列定义两种方式，优先队列内部只保证头部是最值，其它部分可能无序</span></span><br><span class="line">PriorityQueue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;Integer&gt;((a,b)-&gt;&#123;<span class="keyword">return</span> a-b;&#125;);</span><br><span class="line"></span><br><span class="line">PriorityQueue&lt;Integer&gt; queue = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;Integer&gt;(<span class="keyword">new</span> <span class="title class_">Comparator</span>&lt;Integer&gt;()&#123;</span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">compare</span><span class="params">(Integer o1, Integer o2)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> o1.compareTo(o2); <span class="comment">//return o1 - o2;</span></span><br><span class="line"> &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="560-和为-K-的子数组"><a href="#560-和为-K-的子数组" class="headerlink" title="560. 和为 K 的子数组"></a><a href="https://leetcode.cn/problems/subarray-sum-equals-k/">560. 和为 K 的子数组</a></h3><p>前缀和</p><h2 id="普通数组"><a href="#普通数组" class="headerlink" title="普通数组"></a><center>普通数组</center></h2><h3 id="53-最大子数组和"><a href="#53-最大子数组和" class="headerlink" title="53. 最大子数组和"></a><a href="https://leetcode.cn/problems/maximum-subarray/">53. 最大子数组和</a></h3><p><strong>贪心</strong>，遍历求和，如果当前的和小于0，不如直接重置当前和为当前数字；如果当前和大于0，直接继续加，相信美好的事情（变大）会发生，反正每轮都会判断</p><h3 id="56-合并区间"><a href="#56-合并区间" class="headerlink" title="56. 合并区间"></a><a href="https://leetcode.cn/problems/merge-intervals/">56. 合并区间</a></h3><ul><li>二维数组排序，引入comparator，lambda表达式：<code>Arrays.sort(matrix,Comparator.comparingInt(arr -&gt; arr[0]));</code></li><li>list 转数组的 toArray()方法： <code>int[] resarray = listdemo.toArray(new int[listdemo.size()]);</code> 新建一个保存对象相同、数量大小相等的数组； 转二维同样适用，前提是listdemo里面的对象本来就是数组 <code>int[][] resarray = listdemo.toArray(new int[listdemo.size()][]);</code></li></ul><h3 id="189-轮转数组"><a href="#189-轮转数组" class="headerlink" title="189. 轮转数组"></a><a href="https://leetcode.cn/problems/rotate-array/">189. 轮转数组</a></h3><p>用两个数组叠加，重新赋值，注意移位的可能大于数组长度</p><h3 id="238-除自身以外数组的乘积"><a href="#238-除自身以外数组的乘积" class="headerlink" title="238. 除自身以外数组的乘积"></a><a href="https://leetcode.cn/problems/product-of-array-except-self/">238. 除自身以外数组的乘积</a></h3><p><strong>不能用除法，则不考虑前缀积</strong>，左右各遍历一下：第一次遍历，ans保存第i个数字其左侧<code>(0 ~ i-1)</code>的乘积；第二次遍历，当前ans值再乘上 第 i 个数字其右侧<code>(i+1 ~ len-1)</code>的总乘积 即为所求</p><h2 id="矩阵"><a href="#矩阵" class="headerlink" title="矩阵"></a><center>矩阵</center></h2><h3 id="73-矩阵置零"><a href="#73-矩阵置零" class="headerlink" title="73. 矩阵置零"></a><a href="https://leetcode.cn/problems/set-matrix-zeroes/?envType=study-plan-v2&id=top-100-liked">73. 矩阵置零</a></h3><p>标记下标，用 <strong>Set</strong> 记录即可</p><h3 id="54-螺旋矩阵"><a href="#54-螺旋矩阵" class="headerlink" title="54. 螺旋矩阵"></a><a href="https://leetcode.cn/problems/spiral-matrix/?envType=study-plan-v2&id=top-100-liked">54. 螺旋矩阵</a></h3><p>模拟即可，注意处理边界</p><h3 id="48-旋转图像"><a href="#48-旋转图像" class="headerlink" title="48. 旋转图像"></a><a href="https://leetcode.cn/problems/rotate-image/">48. 旋转图像</a></h3><p>模拟即可，注意处理边界</p><h3 id="240-搜索二维矩阵-II"><a href="#240-搜索二维矩阵-II" class="headerlink" title="240. 搜索二维矩阵 II"></a><a href="https://leetcode.cn/problems/search-a-2d-matrix-ii/">240. 搜索二维矩阵 II</a></h3><ul><li><strong>Z字形搜索</strong>，根据数学关系，从右上角开始搜索</li><li>深度搜索，类似求岛屿数量，遍历过的标记</li></ul><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a><center>链表</center></h2><h3 id="160-相交链表"><a href="#160-相交链表" class="headerlink" title="160. 相交链表"></a><a href="https://leetcode.cn/problems/intersection-of-two-linked-lists/?envType=study-plan-v2&id=top-100-liked">160. 相交链表</a></h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//遍历到末尾 换另一条继续，两次过后长度一样</span></span><br><span class="line">A =  A != <span class="literal">null</span> ? A.next : headB;</span><br></pre></td></tr></table></figure><h3 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a><a href="https://leetcode.cn/problems/reverse-linked-list/">206. 反转链表</a></h3><p>new一个<code>pre = null</code>方便操作</p><h3 id="234-回文链表"><a href="#234-回文链表" class="headerlink" title="234. 回文链表"></a><a href="https://leetcode.cn/problems/palindrome-linked-list/">234. 回文链表</a></h3><ul><li>list保存值</li><li>先求出长度，再反转部分</li></ul><h3 id="141-环形链表"><a href="#141-环形链表" class="headerlink" title="141. 环形链表"></a><a href="https://leetcode.cn/problems/linked-list-cycle/?envType=study-plan-v2&id=top-100-liked">141. 环形链表</a></h3><p>快慢指针，有环一定相遇，循环条件 <code>while(fast != slow)</code> 结束条件：<code>fast == slow //相遇了</code> 或 <code>fast = null //到末尾了，说明无环</code></p><h3 id="142-环形链表-II"><a href="#142-环形链表-II" class="headerlink" title="142. 环形链表 II"></a><a href="https://leetcode.cn/problems/linked-list-cycle-ii/">142. 环形链表 II</a></h3><p>数学关系，快慢指针，注意第一次相遇后，fast从头部出发的时速度变为 1</p><h3 id="21-合并两个有序链表"><a href="#21-合并两个有序链表" class="headerlink" title="21. 合并两个有序链表"></a><a href="https://leetcode.cn/problems/merge-two-sorted-lists/">21. 合并两个有序链表</a></h3><p>由于不知道长度，注意处理两条链表的开始和结束</p><h3 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2. 两数相加"></a><a href="https://leetcode.cn/problems/add-two-numbers/">2. 两数相加</a></h3><p>模拟加法过程即可</p><h3 id="19-删除链表的倒数第-N-个结点"><a href="#19-删除链表的倒数第-N-个结点" class="headerlink" title="19. 删除链表的倒数第 N 个结点"></a><a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/?envType=study-plan-v2&id=top-100-liked">19. 删除链表的倒数第 N 个结点</a></h3><p>快慢指针，快的先走n个，注意特殊情况判断</p><h3 id="24-两两交换链表中的节点"><a href="#24-两两交换链表中的节点" class="headerlink" title="24. 两两交换链表中的节点"></a><a href="https://leetcode.cn/problems/swap-nodes-in-pairs/">24. 两两交换链表中的节点</a></h3><ul><li>建立虚拟头部节点，方便操作</li><li>构建 栈 用于改变方向；注意处理模拟的细节</li></ul><h3 id="25-K-个一组翻转链表"><a href="#25-K-个一组翻转链表" class="headerlink" title="25. K 个一组翻转链表"></a><a href="https://leetcode.cn/problems/reverse-nodes-in-k-group/">25. K 个一组翻转链表</a></h3><p> 类似两两交换，引入计数量count即可</p><h3 id="138-复制带随机指针的链表"><a href="#138-复制带随机指针的链表" class="headerlink" title="138. 复制带随机指针的链表"></a><a href="https://leetcode.cn/problems/copy-list-with-random-pointer/">138. 复制带随机指针的链表</a></h3><p><strong>Map</strong> key为原节点，value为新拷贝节点，第一遍创建拷贝，第二遍构建关系</p><h3 id="148-排序链表"><a href="#148-排序链表" class="headerlink" title="148. 排序链表"></a><a href="https://leetcode.cn/problems/sort-list/?envType=study-plan-v2&id=top-100-liked">148. 排序链表</a></h3><p><strong>归并</strong>排序，递归调用，找到中间断开</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ListNode</span> <span class="variable">slow</span> <span class="operator">=</span> head;</span><br><span class="line"><span class="type">ListNode</span> <span class="variable">fast</span> <span class="operator">=</span> head.next;</span><br><span class="line"><span class="keyword">while</span>(fast != <span class="literal">null</span> &amp;&amp; fast.next != <span class="literal">null</span>)&#123;</span><br><span class="line">    slow = slow.next;</span><br><span class="line">    fast = fast.next.next;<span class="comment">//两倍速度</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后面合并的时候，注意可能有没比较完的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h.next = one != <span class="literal">null</span> ? one : two;<span class="comment">//合并时可能一段先遍历完，添加剩下的</span></span><br></pre></td></tr></table></figure><h3 id="23-合并-K-个升序链表"><a href="#23-合并-K-个升序链表" class="headerlink" title="23. 合并 K 个升序链表"></a><a href="https://leetcode.cn/problems/merge-k-sorted-lists/?envType=study-plan-v2&id=top-100-liked">23. 合并 K 个升序链表</a></h3><p>连接为一个链表，再排序</p><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a><center>二叉树</center></h2><h3 id="94-二叉树的中序遍历"><a href="#94-二叉树的中序遍历" class="headerlink" title="94. 二叉树的中序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-inorder-traversal/?envType=study-plan-v2&id=top-100-liked">94. 二叉树的中序遍历</a></h3><p>递归语句放在中间</p><h3 id="104-二叉树的最大深度"><a href="#104-二叉树的最大深度" class="headerlink" title="104. 二叉树的最大深度"></a><a href="https://leetcode.cn/problems/maximum-depth-of-binary-tree/?envType=study-plan-v2&id=top-100-liked">104. 二叉树的最大深度</a></h3><p>左右递归，<code>return Math.max(lefthead, righthead) + 1;</code></p><h3 id="226-翻转二叉树"><a href="#226-翻转二叉树" class="headerlink" title="226. 翻转二叉树"></a><a href="https://leetcode.cn/problems/invert-binary-tree/">226. 翻转二叉树</a></h3><p>左右递归</p><h3 id="101-对称二叉树"><a href="#101-对称二叉树" class="headerlink" title="101. 对称二叉树"></a><a href="https://leetcode.cn/problems/symmetric-tree/">101. 对称二叉树</a></h3><p>多层if，前面的if相当于过滤的作用</p><h3 id="543-二叉树的直径"><a href="#543-二叉树的直径" class="headerlink" title="543. 二叉树的直径"></a><a href="https://leetcode.cn/problems/diameter-of-binary-tree/">543. 二叉树的直径</a></h3><p>转为二叉树的左右深度问题</p><h3 id="102-二叉树的层序遍历"><a href="#102-二叉树的层序遍历" class="headerlink" title="102. 二叉树的层序遍历"></a><a href="https://leetcode.cn/problems/binary-tree-level-order-traversal/?envType=study-plan-v2&id=top-100-liked">102. 二叉树的层序遍历</a></h3><ul><li>队列</li><li>构造好返回类型</li></ul><h3 id="108-将有序数组转换为二叉搜索树"><a href="#108-将有序数组转换为二叉搜索树" class="headerlink" title="108. 将有序数组转换为二叉搜索树"></a><a href="https://leetcode.cn/problems/convert-sorted-array-to-binary-search-tree/?envType=study-plan-v2&id=top-100-liked">108. 将有序数组转换为二叉搜索树</a></h3><p>类似二分，中序顺序，一些辅助函数，经常将整个数组传进去，同时传入一些下标供操作</p><h3 id="98-验证二叉搜索树"><a href="#98-验证二叉搜索树" class="headerlink" title="98. 验证二叉搜索树"></a><a href="https://leetcode.cn/problems/validate-binary-search-tree/">98. 验证二叉搜索树</a></h3><ul><li>对于每个子树而言，无论他是左子树下的右子子树，还是右子树下的左子子树，其中节点值都有范围限制的，递归的时候，动态调整范围大小，类似二分查找时，动态调整区间左右端点的意思</li><li><code>Long.MIN_VALUE</code> 包装类型加上全大写</li></ul><h3 id="230-二叉搜索树中第K小的元素"><a href="#230-二叉搜索树中第K小的元素" class="headerlink" title="230. 二叉搜索树中第K小的元素"></a><a href="https://leetcode.cn/problems/kth-smallest-element-in-a-bst/">230. 二叉搜索树中第K小的元素</a></h3><p>利用中序遍历的特点，注意递归时的结束判断</p><h3 id="199-二叉树的右视图"><a href="#199-二叉树的右视图" class="headerlink" title="199. 二叉树的右视图"></a><a href="https://leetcode.cn/problems/binary-tree-right-side-view/">199. 二叉树的右视图</a></h3><p>层序遍历</p><h3 id="114-二叉树展开为链表"><a href="#114-二叉树展开为链表" class="headerlink" title="114. 二叉树展开为链表"></a><a href="https://leetcode.cn/problems/flatten-binary-tree-to-linked-list/?envType=study-plan-v2&id=top-100-liked">114. 二叉树展开为链表</a></h3><p><code>Queue</code>或者<code>List</code>存储顺序</p><h3 id="105-从前序与中序遍历序列构造二叉树"><a href="#105-从前序与中序遍历序列构造二叉树" class="headerlink" title="105. 从前序与中序遍历序列构造二叉树"></a><a href="https://leetcode.cn/problems/construct-binary-tree-from-preorder-and-inorder-traversal/">105. 从前序与中序遍历序列构造二叉树</a></h3><ul><li>递归时，将数组下标传入，方便操作，注意返回的构造</li><li>当数组元素不重复时，用 <strong>Map</strong> 建立数组下标的索引，方便快速查找数组下标</li></ul><h3 id="437-路径总和-III"><a href="#437-路径总和-III" class="headerlink" title="437. 路径总和 III"></a><a href="https://leetcode.cn/problems/path-sum-iii/?envType=study-plan-v2&id=top-100-liked">437. 路径总和 III</a></h3><p>双递归，第一个递归用来遍历每个节点，在此基础上以每个节点为根节点，进行第二个递归，来实现相应的查找</p><h3 id="236-二叉树的最近公共祖先"><a href="#236-二叉树的最近公共祖先" class="headerlink" title="236. 二叉树的最近公共祖先"></a><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">236. 二叉树的最近公共祖先</a></h3><p>后续遍历，从下到上判断，List保存符合要求的节点，第一个就是最近的祖先</p><h3 id="124-二叉树中的最大路径和"><a href="#124-二叉树中的最大路径和" class="headerlink" title="124. 二叉树中的最大路径和"></a><a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/?envType=study-plan-v2&id=top-100-liked">124. 二叉树中的最大路径和</a></h3><p>双递归，一个用来遍历，一个用来找含当前节点的最大路径片段和</p><h2 id="图论"><a href="#图论" class="headerlink" title=" 图论"></a><center> 图论</center></h2><h3 id="200-岛屿数量"><a href="#200-岛屿数量" class="headerlink" title="200. 岛屿数量"></a><a href="https://leetcode.cn/problems/number-of-islands/?envType=study-plan-v2&id=top-100-liked">200. 岛屿数量</a></h3><p>深度优先遍历：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span>[][] grid, <span class="type">int</span> i, <span class="type">int</span> j)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(i&lt;<span class="number">0</span> || i&gt;=grid.length || j&lt;<span class="number">0</span> || j&gt;=grid[<span class="number">0</span>].length)<span class="keyword">return</span>; <span class="comment">//超出范围</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(grid[i][j] != <span class="number">1</span>) <span class="keyword">return</span>; <span class="comment">//非陆地，或已遍历的陆地</span></span><br><span class="line"></span><br><span class="line">    grid[i][j] = <span class="number">2</span>; <span class="comment">//标记已遍历陆地</span></span><br><span class="line"></span><br><span class="line">    dfs(grid,i-<span class="number">1</span>,j); <span class="comment">//上</span></span><br><span class="line">    dfs(grid,i+<span class="number">1</span>,j); <span class="comment">//下</span></span><br><span class="line">    dfs(grid,i,j-<span class="number">1</span>); <span class="comment">//左</span></span><br><span class="line">    dfs(grid,i,j+<span class="number">1</span>); <span class="comment">//右</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="207-课程表"><a href="#207-课程表" class="headerlink" title="207. 课程表"></a><a href="https://leetcode.cn/problems/course-schedule/?envType=study-plan-v2&id=top-100-liked">207. 课程表</a></h3><ul><li><code>List&lt;List&lt;Integer&gt;&gt; adjacency = new LinkedList&lt;&gt;()</code> 建立邻接表，以及邻接表的初始化</li><li><code>入度</code>、<code>出度</code>的概念</li><li>建立<code>队列</code>辅助操作</li></ul><h3 id="994-腐烂的橘子"><a href="#994-腐烂的橘子" class="headerlink" title="994. 腐烂的橘子"></a><a href="https://leetcode.cn/problems/rotting-oranges/">994. 腐烂的橘子</a></h3><p><code>广度优先</code>，找出所有待操作的值保存入<code>Queue</code>，对queue里面的值进行相应操作</p><h2 id="回溯"><a href="#回溯" class="headerlink" title=" 回溯"></a><center> 回溯</center></h2><h3 id="46-全排列"><a href="#46-全排列" class="headerlink" title="46. 全排列"></a><a href="https://leetcode.cn/problems/permutations/?envType=study-plan-v2&id=top-100-liked">46. 全排列</a></h3><ul><li>引入标志位数组，已遍历置为1，回溯时还原为0</li></ul><h3 id="78-子集"><a href="#78-子集" class="headerlink" title="78. 子集"></a><a href="https://leetcode.cn/problems/subsets/">78. 子集</a></h3><ol><li>所有的组合可以和二进制数形成对应关系，通过二进制数来排列<ul><li><code>左移运算符 &quot;&lt;&lt;&quot;</code> 2 &lt;&lt; 3 : 2 的二进制数<code>00000010</code>整体左移3位，高位舍弃，低位补0 ，变成 <code>00010000</code> 即为 16</li><li><code>带符号右移运算符 &quot;&lt;&lt;&quot;</code></li></ul><ol><li>7 &gt;&gt; 2 : 7 的二进制数<code>00000111</code>整体右移2位，7是正数，所以高位全补0，低位舍弃，变成<code>00000001</code> 即为1</li><li>-9 &gt;&gt; 2 : -9 的二进制数（补码）<code>1111 0111</code>整体右移2位，-9是负数，所以高位全补1，低位舍弃，变成<code>1111 1101</code> 即为 -3</li></ol><ul><li><code>无符号右移运算符 &quot;&lt;&lt;&lt;&quot;</code> 无论正负，高位全补0</li></ul></li><li>递归，数组每一位存在要或者不要两种情况，全局的 栈 或 list 保存递归过程的情况</li></ol><h3 id="17-电话号码的字母组合"><a href="#17-电话号码的字母组合" class="headerlink" title="17. 电话号码的字母组合"></a><a href="https://leetcode.cn/problems/letter-combinations-of-a-phone-number/">17. 电话号码的字母组合</a></h3><p>递归，依次遍历</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;LeetCode-热题-100&quot;&gt;&lt;a href=&quot;#LeetCode-热题-100&quot; class=&quot;headerlink&quot; title=&quot; LeetCode 热题 100&quot;&gt;&lt;/a&gt;&lt;center&gt; &lt;a href=&quot;https://leetcode.cn/st</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>first</title>
    <link href="https://jingxiao-yz.github.io/2023/05/04/first/"/>
    <id>https://jingxiao-yz.github.io/2023/05/04/first/</id>
    <published>2023-05-04T11:01:31.000Z</published>
    <updated>2023-05-04T15:09:11.369Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2023/05/04/first/%E5%A4%B4%E5%83%8F.jpg" alt="头像"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;/2023/05/04/first/%E5%A4%B4%E5%83%8F.jpg&quot; alt=&quot;头像&quot;&gt;&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
</feed>
